class MinMaxNumeric {
    ~MinMaxNumeric() {}

    min_int_8() { return -128; }
    max_int_8() { return 127; }
    min_uint_8() { return 0; }
    max_uint_8() { return 255; }
    min_int_16() { return -32768; }
    max_int_16() { return 32767; }
    min_uint_16() { return 0; }
    max_uint_16() { return 65535; }
    min_int_32() { return -2147483647 - 1; }
    max_int_32() { return 2147483647; }
    min_uint_32() { return 0; }
    max_uint_32() { return (2147483647 * 2) + 1; }
}

class Test {

    benchmark() {
        // Object to contain basic numeric limits.
        def limits = new MinMaxNumeric();

        // Association of simple variables to evaluate the basic correctness of the validation.
        def just_zero =             0;                          // This should not generate any warnings.
        def just_negative =         -1;                         // This should generate a warning for all non-negative types.
        def more_than_127 =         limits.max_int_8() + 1;     // This should generate a warning for the int8 type.
        def more_than_255 =         limits.max_uint_8() + 1;    // This should generate a warning for int8 and uint8 types.
        def more_than_32767 =       limits.max_int_16() + 1;    // This should generate a warning for int8, uint8, and int16 types.
        def more_than_65535 =       limits.max_uint_16() + 1;   // This should generate a warning for int8, uint8, int16, and uint16 types.
        def more_than_2147483647 =  limits.max_int_32() + 1;    // This should generate a warning for int8, uint8, int16, uint16, and int32 types.
        def more_than_4294967295 =  limits.max_uint_32() + 1;   // This should generate a warning for int8, uint8, int16, uint16, int32, and uint32 types.
        def less_than_m128 =        limits.min_int_8() - 1;     // This should generate a warning for all non-negative types and for int8.
        def less_than_m32768 =      limits.min_int_16() - 1;    // This should generate a warning for all non-negative types and for int8, and int16.
        def less_than_m2147483648 = limits.min_int_32() - 1;    // This should generate a warning for all non-negative types and for int8, int16, and int32.

        // Association of simple floating point variables to evaluate the basic correctness of the validation.
        def just_zero_fp = 0.0;                             // This should not generate any warnings.
        def close_to_zero_8 = 0.015624;                     // This should generate a warning since the value for float8 is close to zero.
        def round_to_zero_8 = 0.001953124;                  // This should generate a warning since the value for float8 will round to zero.
        def close_to_zero_16 = 0.00006103515624;            // This should generate a warning since the value for float8 and float16 are close to zero.
        def round_to_zero_16 = 0.000000059604644775390625;  // This should generate a warning since the value for float8 and float16 will round to zero.

        def small_float_32 = 0.00000000000000000000009;             // Base value for compute small 32 floating point values.
        def close_to_zero_32 = small_float_32 * small_float_32;     // This should generate a warning since the value for float8, float16, and float32 are close to zero.
        def round_to_zero_32 = close_to_zero_32 * small_float_32;   // This should generate a warning since the value for float8, float16, and float32 will round to zero.

        // This should successfully prevent the else branch from marking the eq_comparison_not_overflowing variable as
        // overflowing.
        def eq_comparison_not_overflowing = 0;
        if (just_zero == 0) { eq_comparison_not_overflowing = 1; }
        else { eq_comparison_not_overflowing = limits.max_int_8() + 1; }

        // This should allow to successfully access the else branch and mark the eq_comparison_overflowing variable as
        // overflowing.
        def eq_comparison_overflowing = 0;
        if (just_zero != 0) { eq_comparison_overflowing = 1; }
        else { eq_comparison_overflowing = limits.max_int_8() + 1; }

        // This should successfully prevent the true branch from marking the gt_comparison_not_overflowing variable as
        // overflowing.
        def gt_comparison_not_overflowing = 0;
        if (just_zero > 0) { gt_comparison_not_overflowing = limits.max_int_8() + 1;  }
        else { gt_comparison_not_overflowing = 1; }

        // This should allow to successfully access the true branch and mark the gt_comparison_overflowing variable as
        // overflowing.
        def gt_comparison_overflowing = 0;
        if (more_than_127 > 0) { gt_comparison_overflowing = limits.max_int_8() + 1;  }
        else { gt_comparison_overflowing = 1; }

        // This should successfully prevent the true branch from marking the lt_comparison_not_overflowing variable as
        // overflowing.
        def lt_comparison_not_overflowing = 0;
        if (just_zero < 0) { lt_comparison_not_overflowing = limits.max_int_8() + 1;  }
        else { lt_comparison_not_overflowing = 1; }

        // This should allow to successfully access the true branch and mark the lt_comparison_overflowing variable as
        // overflowing.
        def lt_comparison_overflowing = 0;
        if (just_negative < 0) { lt_comparison_overflowing = limits.max_int_8() + 1;  }
        else { lt_comparison_overflowing = 1; }

        // This should successfully prevent the else branch from marking the ge_comparison_not_overflowing0 variable as
        // overflowing.
        def ge_comparison_not_overflowing0 = 0;
        if (just_zero >= 0) { ge_comparison_not_overflowing0 = 1;  }
        else { ge_comparison_not_overflowing0 = limits.max_int_8() + 1; }

        // This should successfully prevent the else branch from marking the ge_comparison_not_overflowing1 variable as
        // overflowing.
        def ge_comparison_not_overflowing1 = 0;
        if (more_than_127 >= 0) { ge_comparison_not_overflowing1 = 1;  }
        else { ge_comparison_not_overflowing1 = limits.max_int_8() + 1; }

        // This should successfully mark ge_comparison_overflowing2 variable as overflowing.
        def ge_comparison_overflowing2 = 0;
        if (just_negative >= 0) { ge_comparison_overflowing2 = 1;  }
        else { ge_comparison_overflowing2 = limits.max_int_8() + 1; }

        // This should successfully prevent the else branch from marking the le_comparison_not_overflowing0 variable as
        // overflowing.
        def le_comparison_not_overflowing0 = 0;
        if (just_zero <= 0) { le_comparison_not_overflowing0 = 1;  }
        else { le_comparison_not_overflowing0 = limits.max_int_8() + 1; }

        // This should successfully prevent the else branch from marking the le_comparison_not_overflowing1 variable as
        // overflowing.
        def le_comparison_not_overflowing1 = 0;
        if (just_negative <= 0) { le_comparison_not_overflowing1 = 1;  }
        else { le_comparison_not_overflowing1 = limits.max_int_8() + 1; }

        // This should successfully mark le_comparison_overflowing2 variable as overflowing.
        def le_comparison_overflowing2 = 0;
        if (more_than_127 <= 0) { le_comparison_overflowing2 = 1;  }
        else { le_comparison_overflowing2 = limits.max_int_8() + 1; }
    }
}//
// short benchmark program to test OverFlowChecker
// even if NOT exhaustive, it produces some border-line intervals to simulate both possible and definite ufs/ofs
// works best against NumericalSize.FLOAT8 (if you adapt it, it may be used against any other NumericalSize though)
//
// Disclaimer : may contain catastrofic errors...
//

class Tests {

	some_numeric_function(unknown) {
		def some = 10;
		if (unknown == 123) {
			some = some + 0.001;
		}
		return some;                                          // some         = [10, 10.001]
	}

	test_bad_flows_FP8(unknown) {

		def uncertain = this.some_numeric_function(unknown);
		
		def sure_pos_ofl_6    = 8 * uncertain * uncertain;    // sure_pos_ofl_6    = [800,      800.160008]
		def sure_pos_ofl_7    = 80 * 80;                      // sure_pos_ofl_7    = [6400,    6400]

		def sure_neg_ofl_1    = uncertain         * -25;      // sure_neg_ofl_1    = [-250.025,   -250]
		def maybe_neg_ofl_1   = sure_neg_ofl_1    + 10.01;    // maybe_neg_ofl_1   = [-240.015,   -239.99]
		def NO_neg_ofl        = maybe_neg_ofl_1   + 10;       // NO_neg_ofl        = [-230.015,   -229.99]
		def maybe_neg_ofl_2   = NO_neg_ofl        + 229.989;  // maybe_neg_ofl_2   = [  -0.026,   -0.001]
		def sure_neg_ofl_2    = maybe_neg_ofl_2   / 100;      // sure_neg_ofl_2    = [  -0.00026, -0.00001]
		def maybe_cross_ofl_3 = NO_neg_ofl        + 230;      // maybe_cross_ofl_3 = [  -0.015,    0.01]
		def maybe_cross_ofl_4 = maybe_cross_ofl_3 * 100;      // maybe_cross_ofl_4 = [  -1.5,      1]
		def maybe_cross_ofl_5 = maybe_cross_ofl_4 * 230 + 70; // maybe_cross_ofl_5 = [-275,      300]

		def sure_pos_ofl_2    = -sure_neg_ofl_2;
		def maybe_pos_ofl_2   = -maybe_neg_ofl_2;
		def NO_pos_ofl        = -NO_neg_ofl;
		def maybe_pos_ofl_1   = -maybe_neg_ofl_1;
		def sure_pos_ofl_1    = -sure_neg_ofl_1;

	}
   
}
ÿþ/ /   9 0 8 0 9 3   -   I M P   f i l e   f o r   O v e r f l o w   &   U n d e r f l o w   C h e c k e r  c l a s s   o v e r f l o w _ u n d e r f l o w   {           w a r n i n g I N T 8 ( )   {          d e f   z   =   " h e l l o " ;                 / /   S T R I N G          d e f   w   =   9 9   +   z ;                   / /   U N D E F .   T Y P E          }   	 t e s t I N T 8 ( )   {  	 	 d e f   a   =   1 2 7 ;  	 	 d e f   b   =   a   +   1 ;             / /   O V E R F L O W  	 	 d e f   c   =   - 1 2 8 ;  	 	 d e f   d   =   c   -   1 ;             / /   U N D E R F L O W  	 	 d e f   e   =   5 0   +   5 0 ;         / /   O K  	 }   	 t e s t U I N T 8 ( )   {  	 	 d e f   a   =   2 5 5 ;  	 	 d e f   b   =   a   +   1 ;             / /   O V E R F L O W  	 	 d e f   c   =   0 ;  	 	 d e f   d   =   c   -   1 ;             / /   U N D E R F L O W  	 	 d e f   e   =   1 0 0   +   1 0 0 ;     / /   O K  	 }    	 t e s t I N T 1 6 ( )   {  	 	 d e f   a   =   3 2 7 6 7 ;  	 	 d e f   b   =   a   +   1 ;               / /   O V E R F L O W  	 	 d e f   c   =   - 3 2 7 6 8 ;  	 	 d e f   d   =   c   -   1 ;               / /   U N D E R F L O W  	 	 d e f   e   =   1 0 0 0   +   2 0 0 0 ;   / /   O K  	 }    	 t e s t U I N T 1 6 ( )   {  	 	 d e f   a   =   6 5 5 3 5 ;  	 	 d e f   b   =   a   +   1 ;                 / /   O V E R F L O W  	 	 d e f   c   =   0 ;  	 	 d e f   d   =   c   -   1 ;                 / /   U N D E R F L O W  	 	 d e f   e   =   3 5 0 0 0   +   2 5 0 0 0 ;   / /   O K  	 }    	 t e s t I N T 3 2 ( )   {  	 	 d e f   a   =   2 1 4 7 4 8 3 6 4 7 ;  	 	 d e f   b   =   a   +   1 ;                 / /   O V E R F L O W  	 	 d e f   c   =   - 2 1 4 7 4 8 3 6 4 8 . 0 ;  	 	 d e f   d   =   c   -   1 ;                 / /   U N D E R F L O W  	 }    	 t e s t U I N T 3 2 ( )   {  	 	 d e f   a   =   4 2 9 4 9 6 7 2 9 5 . 0 ;  	 	 d e f   b   =   a   +   1 ;                 / /   O V E R F L O W  	 	 d e f   c   =   0 ;  	 	 d e f   d   =   c   -   1 ;                 / /   U N D E R F L O W  	 }    	 t e s t F L O A T 8 ( )   {  	 	 d e f   a   =   2 3 9 . 0 ;  	 	 d e f   b   =   a   *   2 . 7 8 3 ;         / /   O V E R F L O W  	 	 d e f   c   =   - 2 3 9 . 0 ;  	 	 d e f   d   =   c   *   2 . 5 3 9 ;         / /   U N D E R F L O W  	 	 d e f   e   =   0 . 1 ;  	 	 d e f   f   =   e   /   6 . 0 ;             / /   w i t h i n   t h e   b o u n d s  	 }    	 t e s t F L O A T 1 6 ( )   {  	 	 d e f   a   =   6 5 0 0 0 . 0 ;  	 	 d e f   b   =   a   *   2 . 0 ;               / /   O V E R F L O W  	 	 d e f   c   =   - 6 5 0 0 0 . 0 ;  	 	 d e f   d   =   c   *   2 . 0 ;               / /   U N D E R F L O W  	 	 d e f   e   =   - 1 0 0 0 . 0 ;  	 	 d e f   f   =   e   /   0 . 0 5 ;             / /   O K  	 	 d e f   g   =   f   -   6 5 0 0 0 . 0 ;       / /   U N D E R F L O W  	 }    	 t e s t F L O A T 3 2 ( )   {  	 	 d e f   a   =   3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . 0 ;  	 	 d e f   b   =   a   *   1 0 . 0 ;                             / /   O V E R F L O W  	 	 d e f   c   =   - 3 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . 0 ;  	 	 d e f   d   =   c   *   1 0 . 0 ;                             / /   U N D E R F L O W  	 	 d e f   e   =   1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . 0 ;  	 	 d e f   f   =   ( e   /   1 0 0 0 . 0 1 )   *   a ;           / /   O V E R F L O W  	 }   / /   C O N D I T I O N E D   T E S T   C A S E S           / /   I N T 8   p o s s i b l e   o v e r f l o w  	 c o n d i t i o n a l O v e r f l o w I N T 8 ( c o n d )   {  	 	 d e f   a   =   1 0 0 ;  	 	 i f   ( c o n d )   {  	 	 	 a   =   1 2 7 ;  	 	 }  	 	 d e f   b   =   a   +   1 ;     / /   p o s s i b l e   o v e r f l o w   i f   a   =   1 2 7  	 }   	 / /   U I N T 8   p o s s i b l e   u n d e r f l o w  	 c o n d i t i o n a l U n d e r f l o w U I N T 8 ( f l a g )   {  	 	 d e f   x   =   1 0 ;  	 	 i f   ( f l a g )   {  	 	 	 x   =   0 ;  	 	 }  	 	 d e f   y   =   x   -   1 ;     / /   y   b e l o n g s   t o   [ - 1 ,   9 ]   s o   p o s s i b l e   U N D E R F L O W  	 }   	 / /   U I N T 1 6   p o s s i b l e   o v e r f l o w  	 l o o p O v e r f l o w U I N T 1 6 ( c o n d )   {  	 	 d e f   a   =   0 ;  	 	 w h i l e   ( c o n d )   {  	 	 	 a   =   a   +   1 0 0 0 0 ;  	 	 }  	 	 d e f   b   =   a   +   1 0 0 0 0 ;   / /   m a y   b e   g r e a t e r   t h a n   6 5 5 3 5   s o   p o t e n t i a l   o v e r f l o w  	 }   	 / /   I N T 1 6   p o s s i b l e   o v e r f l o w  	 p r e v e n t e d O v e r f l o w I N T 1 6 ( l i m i t )   {  	 	 d e f   a   =   3 2 0 0 0 ;  	 	 i f   ( l i m i t   <   0 )   {  	 	 	 a   =   a   +   1 0 0 0 ;     / /   s a f e   i f   b r a n c h   i s   n o t   e x e c u t e d  	 	 }  	 	 d e f   b   =   a   +   5 0 0 ;   / /   b   i s   w i t h i n   [ 3 2 5 0 0 ,   3 3 5 0 0 ] ,   o v e r f l o w   o c c u r s   i f   b r a n c h   e x e c u t e d  	 }   	 / /   U I N T 3 2   p o s s i b l e   u n d e r f l o w  	 p r e v e n t e d U n d e r f l o w U I N T 3 2 ( l i m i t )   {  	 	 d e f   a   =   1 0 0 0 ;  	 	 i f   ( l i m i t   <   0 )   {  	 	 	 a   =   a   -   2 0 0 0 ;     / /   m a y   u n d e r f l o w   i f   b r a n c h   i s   e x e c u t e d  	 	 }  	 	 d e f   b   =   a   -   5 0 0 ;     / /   b   i s   w i t h i n   [ - 1 5 0 0 ,   5 0 0 ] ,   p o s s i b l e   u n d e r f l o w  	 }   	 / /   F L O A T 1 6   n o   u n d e r f l o w / o v e r f l o w  	 n o U n d e r f l o w B y C o n d i t i o n F L O A T 1 6 ( s m a l l )   {  	 	 d e f   f   =   1 . 0 ;  	 	 i f   ( s m a l l )   {  	 	 	 f   =   0 . 0 7 ;  	 	 }  	 	 d e f   r e s u l t   =   f   *   0 . 0 0 1 ;     / /   s a f e  	 }  } 