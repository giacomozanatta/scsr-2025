class MinMaxNumeric {
    ~MinMaxNumeric() {}

    min_int_8() { return -128; }
    max_int_8() { return 127; }
    min_uint_8() { return 0; }
    max_uint_8() { return 255; }
    min_int_16() { return -32768; }
    max_int_16() { return 32767; }
    min_uint_16() { return 0; }
    max_uint_16() { return 65535; }
    min_int_32() { return -2147483647 - 1; }
    max_int_32() { return 2147483647; }
    min_uint_32() { return 0; }
    max_uint_32() { return (2147483647 * 2) + 1; }
}

class Test {

    benchmark() {
        // Object to contain basic numeric limits.
        def limits = new MinMaxNumeric();

        // Association of simple variables to evaluate the basic correctness of the validation.
        def just_zero =             0;                          // This should not generate any warnings.
        def just_negative =         -1;                         // This should generate a warning for all non-negative types.
        def more_than_127 =         limits.max_int_8() + 1;     // This should generate a warning for the int8 type.
        def more_than_255 =         limits.max_uint_8() + 1;    // This should generate a warning for int8 and uint8 types.
        def more_than_32767 =       limits.max_int_16() + 1;    // This should generate a warning for int8, uint8, and int16 types.
        def more_than_65535 =       limits.max_uint_16() + 1;   // This should generate a warning for int8, uint8, int16, and uint16 types.
        def more_than_2147483647 =  limits.max_int_32() + 1;    // This should generate a warning for int8, uint8, int16, uint16, and int32 types.
        def more_than_4294967295 =  limits.max_uint_32() + 1;   // This should generate a warning for int8, uint8, int16, uint16, int32, and uint32 types.
        def less_than_m128 =        limits.min_int_8() - 1;     // This should generate a warning for all non-negative types and for int8.
        def less_than_m32768 =      limits.min_int_16() - 1;    // This should generate a warning for all non-negative types and for int8, and int16.
        def less_than_m2147483648 = limits.min_int_32() - 1;    // This should generate a warning for all non-negative types and for int8, int16, and int32.

        // Association of simple floating point variables to evaluate the basic correctness of the validation.
        def just_zero_fp = 0.0;                             // This should not generate any warnings.
        def close_to_zero_8 = 0.015624;                     // This should generate a warning since the value for float8 is close to zero.
        def round_to_zero_8 = 0.001953124;                  // This should generate a warning since the value for float8 will round to zero.
        def close_to_zero_16 = 0.00006103515624;            // This should generate a warning since the value for float8 and float16 are close to zero.
        def round_to_zero_16 = 0.000000059604644775390625;  // This should generate a warning since the value for float8 and float16 will round to zero.

        def small_float_32 = 0.00000000000000000000009;             // Base value for compute small 32 floating point values.
        def close_to_zero_32 = small_float_32 * small_float_32;     // This should generate a warning since the value for float8, float16, and float32 are close to zero.
        def round_to_zero_32 = close_to_zero_32 * small_float_32;   // This should generate a warning since the value for float8, float16, and float32 will round to zero.

        // This should successfully prevent the else branch from marking the eq_comparison_not_overflowing variable as
        // overflowing.
        def eq_comparison_not_overflowing = 0;
        if (just_zero == 0) { eq_comparison_not_overflowing = 1; }
        else { eq_comparison_not_overflowing = limits.max_int_8() + 1; }

        // This should allow to successfully access the else branch and mark the eq_comparison_overflowing variable as
        // overflowing.
        def eq_comparison_overflowing = 0;
        if (just_zero != 0) { eq_comparison_overflowing = 1; }
        else { eq_comparison_overflowing = limits.max_int_8() + 1; }

        // This should successfully prevent the true branch from marking the gt_comparison_not_overflowing variable as
        // overflowing.
        def gt_comparison_not_overflowing = 0;
        if (just_zero > 0) { gt_comparison_not_overflowing = limits.max_int_8() + 1;  }
        else { gt_comparison_not_overflowing = 1; }

        // This should allow to successfully access the true branch and mark the gt_comparison_overflowing variable as
        // overflowing.
        def gt_comparison_overflowing = 0;
        if (more_than_127 > 0) { gt_comparison_overflowing = limits.max_int_8() + 1;  }
        else { gt_comparison_overflowing = 1; }

        // This should successfully prevent the true branch from marking the lt_comparison_not_overflowing variable as
        // overflowing.
        def lt_comparison_not_overflowing = 0;
        if (just_zero < 0) { lt_comparison_not_overflowing = limits.max_int_8() + 1;  }
        else { lt_comparison_not_overflowing = 1; }

        // This should allow to successfully access the true branch and mark the lt_comparison_overflowing variable as
        // overflowing.
        def lt_comparison_overflowing = 0;
        if (just_negative < 0) { lt_comparison_overflowing = limits.max_int_8() + 1;  }
        else { lt_comparison_overflowing = 1; }

        // This should successfully prevent the else branch from marking the ge_comparison_not_overflowing0 variable as
        // overflowing.
        def ge_comparison_not_overflowing0 = 0;
        if (just_zero >= 0) { ge_comparison_not_overflowing0 = 1;  }
        else { ge_comparison_not_overflowing0 = limits.max_int_8() + 1; }

        // This should successfully prevent the else branch from marking the ge_comparison_not_overflowing1 variable as
        // overflowing.
        def ge_comparison_not_overflowing1 = 0;
        if (more_than_127 >= 0) { ge_comparison_not_overflowing1 = 1;  }
        else { ge_comparison_not_overflowing1 = limits.max_int_8() + 1; }

        // This should successfully mark ge_comparison_overflowing2 variable as overflowing.
        def ge_comparison_overflowing2 = 0;
        if (just_negative >= 0) { ge_comparison_overflowing2 = 1;  }
        else { ge_comparison_overflowing2 = limits.max_int_8() + 1; }

        // This should successfully prevent the else branch from marking the le_comparison_not_overflowing0 variable as
        // overflowing.
        def le_comparison_not_overflowing0 = 0;
        if (just_zero <= 0) { le_comparison_not_overflowing0 = 1;  }
        else { le_comparison_not_overflowing0 = limits.max_int_8() + 1; }

        // This should successfully prevent the else branch from marking the le_comparison_not_overflowing1 variable as
        // overflowing.
        def le_comparison_not_overflowing1 = 0;
        if (just_negative <= 0) { le_comparison_not_overflowing1 = 1;  }
        else { le_comparison_not_overflowing1 = limits.max_int_8() + 1; }

        // This should successfully mark le_comparison_overflowing2 variable as overflowing.
        def le_comparison_overflowing2 = 0;
        if (more_than_127 <= 0) { le_comparison_overflowing2 = 1;  }
        else { le_comparison_overflowing2 = limits.max_int_8() + 1; }
    }
}